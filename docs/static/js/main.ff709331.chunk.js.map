{"version":3,"sources":["fsm.ts","components/MachineSimulator.tsx","pages/Minimizer.tsx","pages/Simulator.tsx","pages/Home.tsx","App.tsx","index.tsx"],"names":["PATTERNS","STATES","INITIAL","ACCEPTING","ALPHABET","TRANSITIONS","StateMachine","Graph","constructor","options","super","multigraph","initial","alphabet","Set","accepted","this","setGraph","rankdir","parse","description","build","isAccepted","input","node","testInput","undefined","has","setInitial","setAccepted","name","label","add","setNode","setSymbol","setTransition","v","w","symbol","edge","symbols","includes","setEdge","transitions","edges","transition","t","hash","btoa","minimize","nodes","length","desc","join","size","map","flatMap","c","R","reachable","F","setIntersect","Q","setDiff","P","W","A","pop","X","state","Y","diff","intr","splice","indexOf","push","K","filter","p","names","Map","M","forEach","k","s","set","get","peripheries","outEdges","e","found","digraph","states","accept","Error","some","start","queue","visited","current","a","b","value","parse_initial","parse_states","parse_accepting","parse_alphabet","parse_transitions","statesMatch","exec","split","trim","initialMatch","acceptMatch","alphabetMatch","transMatch","matchAll","MachineSimulator","_ref","props","error","setError","useState","parsed","setParsed","useEffect","graph","fsm","finalNode","fillcolor","style","output","dot","write","read","message","_jsx","Graphviz","children","defaultProps","Minimizer","setDescription","minimized","setMinimized","setHash","minimizedHash","setMinimizedHash","base","machine","_jsxs","Container","Row","Col","InputGroup","height","Prepend","Text","FormControl","as","onChange","target","width","disabled","Simulator","DEFAULT_MACHINE","setInput","Home","Link","to","App","Router","basename","Navbar","className","maxWidth","collapseOnSelect","expand","variant","Brand","Toggle","Collapse","id","Nav","NavLink","Switch","Route","path","exact","ReactDOM","render","React","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ff709331.chunk.js","sourcesContent":["import { Edge, Graph, GraphOptions } from \"graphlib\";\n\nconst PATTERNS = {\n    STATES: /:states:\\s*((\\w+\\s*)+)/,\n    INITIAL: /:initial:\\s*(\\w+)\\s*/,\n    ACCEPTING: /:accept:\\s*((\\w+\\s*)+)/,\n    ALPHABET: /:alphabet:\\s*((\\w\\s*)+)/,\n    TRANSITIONS: /:transitions:\\n((\\w+\\s*,\\s*\\w+\\s*>\\s*\\w+\\n?)*)/\n}\n\n/**\n * JSON compatible description of a {@link StateMachine}\n */\nexport interface StateMachineDescription {\n    states: string[],\n    initial: string;\n    accept?: string[];\n    alphabet: string[];\n    transitions?: Array<[string, string, string]>;\n}\n\nexport interface StateMachineOptions extends GraphOptions {\n    description?: string | StateMachineDescription;\n}\n\ninterface Transition extends Edge {\n}\n\n/**\n * Graph representation of a finite state machine.\n */\nexport class StateMachine extends Graph {\n    private initial!: string;\n\n    private alphabet: Set<string> = new Set();\n    private accepted: Set<string> = new Set();\n\n    public constructor(options?: StateMachineOptions) {\n        super({ ...options, multigraph: true });\n\n        this.setGraph({ rankdir: \"LR\" })\n    }\n\n    /**\n     * Construct a new {@link StateMachine} from a string or JSON representation.\n     * @param {string|StateMachineDescription} description\n     * @returns {StateMachine}\n     */\n    public static parse(description: string | StateMachineDescription): StateMachine {\n        if (typeof description === \"string\") {\n            return this.build(parse(description));\n        } else {\n            return this.build(description);\n        }\n    }\n\n    /**\n     * Check if an input string is accepted by the {@link StateMachine}\n     * @param {string} input\n     * @returns {boolean}\n     */\n    public isAccepted(input: string): boolean {\n        const node = this.testInput(input);\n        return node !== undefined && this.accepted.has(node);\n    }\n\n    /**\n     * Set the initial state on the state machine.\n     * @param initial\n     */\n    public setInitial(initial: string): this {\n        this.initial = initial;\n\n        return this;\n    }\n\n    /**\n     * Set a state as accepted on the state machine.\n     * @param name\n     * @param label\n     */\n    public setAccepted(name: string, label: any): this {\n        this.accepted.add(name);\n\n        return this.setNode(name, label) as this;\n    }\n\n    /**\n     * Add a symbol to the state machine's alphabet.\n     * @param name\n     * @param label\n     */\n    public setSymbol(name: string, label: any): this {\n        this.alphabet.add(name);\n\n        return this;\n    }\n\n    /**\n     * Add a transition to the state machine.\n     * @param {string} v The starting state.\n     * @param {string} w The ending state.\n     * @param {string} symbol The symbol for which the transition occurs.\n     */\n    public setTransition(v: string, w: string, symbol: string): this {\n        const edge = this.edge(v, w) as { label: string, symbols: string[] };\n\n        if (edge) {\n            if (edge.symbols.includes(symbol)) {\n                return this;\n            } else {\n                return this.setEdge(v, w, { label: `${edge.label},${symbol}`, symbols: [...edge.symbols, symbol] }) as this;\n            }\n        }\n\n        return this.setEdge(v, w, { label: symbol, symbols: [symbol] }) as this;\n    }\n\n    /**\n     * Retrieve all transitions on the StateMachine.\n     * Alias for {@link StateMachine.edges}\n     * @returns {Transition[]}\n     */\n    public transitions(): Transition[] {\n        return this.edges();\n    }\n\n    /**\n     * Retrieve the data associated with a transition.\n     * Alias for {@link StateMachine.edge}\n     * @param {Transition} t\n     */\n    public transition(t: Transition): Transition {\n        return this.edge(t);\n    }\n\n    /**\n     * A unique hash based on the description of the machine.\n     */\n    public hash(): string {\n        return btoa(this.minimize().description());\n    }\n\n    /**\n     * Build the textual description of this machine.\n     * This can be used for debugging or constructing other machines.\n     * @returns {string}\n     */\n    public description(): string {\n        if (this.nodes().length === 0) return \"\";\n\n        let desc = \"\";\n        desc += `:states:\\n${this.nodes().join(\"\\n\")}\\n`;\n        desc +=  `:initial:\\n${this.initial}\\n`;\n\n        if (this.accepted.size > 0) {\n            desc += `:accept:\\n${[...this.accepted].join(\"\\n\")}\\n`;\n        }\n\n        if (this.alphabet.size > 0) {\n            desc += `:alphabet:\\n${[...this.alphabet].join(\"\\n\")}\\n`;\n        }\n\n        if (this.transitions().length > 0) {\n            desc += `:transitions:\\n${\n                this.transitions()\n                  .map(t => ({ v: t.v, w: t.w, symbols: this.edge(t).symbols}))\n                  .flatMap(t => t.symbols.map((c: string) => `${t.v}, ${c} > ${t.w}`))\n                  .join(\"\\n\")\n            }\\n`;\n        }\n\n        return desc;\n    }\n\n    /**\n     * Implementation of Hopcroft's algorithm\n     * https://en.wikipedia.org/wiki/DFA_minimization\n     * @returns {StateMachine} A new {@link StateMachine}\n     */\n    public minimize(): StateMachine {\n        const R = this.reachable();\n        const F = this.setIntersect(this.accepted, R);\n        const Q = this.setIntersect(this.setDiff(new Set(this.nodes()), F), R);\n\n        let P = [F, Q];\n        let W = [F, Q];\n\n        while (W.length > 0) {\n            const A = W.pop()!;\n\n            for (const c of this.alphabet) {\n                const X = new Set<string>();\n\n                for (const transition of this.transitions()) {\n                    const attrs = this.edge(transition);\n                    if (attrs.symbols.includes(c)) {\n                        for (const state of A) {\n                            if (transition.w === state) {\n                                X.add(transition.v);\n                            }\n                        }\n                    }\n                }\n\n                P = P.flatMap(Y => {\n                    const diff = this.setDiff(Y, X);\n                    const intr = this.setIntersect(X, Y);\n                    if (diff.size > 0 && intr.size > 0) {\n                        if (W.includes(Y)) {\n                            W.splice(W.indexOf(Y), 1);\n\n                            W.push(intr, diff);\n                        } else {\n                            W.push(intr.size <= diff.size ? intr : diff);\n                        }\n\n                        return [intr, diff];\n                    } else {\n                        return Y;\n                    }\n                });\n            }\n        }\n\n        const K = P.filter(p => p.size > 0);\n        const names = new Map<string, string>();\n\n        const M = new StateMachine({ multigraph: true });\n\n        K.forEach(k => {\n            const name = [...k].join(\"\");\n            k.forEach(s => names.set(s, name));\n        });\n\n        K.forEach(k => {\n            const s = [...k][0];\n\n            M.setNode(names.get(s)!);\n\n            if (this.accepted.has(s)) {\n                M.setAccepted(names.get(s)!, { peripheries: 2 })\n            }\n\n            (this.outEdges(s) as Edge[]).forEach(e => {\n                this.edge(e).symbols.forEach((c: string) => {\n                    M.setTransition(names.get(s)!, names.get(e.w)!, c);\n                });\n            });\n        });\n\n        M.setInitial(names.get(this.initial)!);\n\n        [...this.alphabet].forEach(c => M.setSymbol(c, {}))\n\n        return M;\n    }\n\n    public testInput(input: string): string | undefined {\n        let node = this.initial;\n\n        for (const c of input) {\n            if (!this.alphabet.has(c)) {\n                return undefined;\n            }\n\n            const edges = this.outEdges(node);\n\n            let found = false;\n            if (edges) {\n                for (const e of edges) {\n                    const edge = this.edge(e);\n\n                    if (edge.symbols.includes(c)) {\n                        node = e.w;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!found) {\n                return node;\n            }\n        }\n\n        return node;\n    }\n\n    private static build(description: StateMachineDescription): StateMachine {\n        const digraph = new StateMachine();\n\n        const { states, initial, accept, alphabet, transitions } = description;\n\n        if (!states) {\n            return digraph;\n        }\n\n        if (!initial) {\n            throw new Error(\"Cannot parse StateMachine with no initial state!\");\n        } else {\n            if (!states.includes(initial)) {\n                throw new Error(\"Initial state set to a state that does not exist!\");\n            }\n        }\n\n        if (accept && accept.length > 0 && accept.some(s => !states.includes(s))) {\n            throw new Error(\"Accepted states includes a state that does not exist!\");\n        }\n\n        if (transitions && transitions.length > 0) {\n            if (!alphabet || alphabet.length === 0) {\n                throw new Error(\"Cannot specify transitions with an empty alphabet!\");\n            }\n\n            if (transitions.some(t => !alphabet.includes(t[1]))) {\n                throw new Error(\"Transition includes a symbol which is not defined in the alphabet!\");\n            }\n\n            if (transitions.some(t => !states.includes(t[0]) || !states.includes(t[2]))) {\n                throw new Error(\"Transition includes a state which is not defined in states!\");\n            }\n        }\n\n        (alphabet || []).forEach(c => digraph.setSymbol(c, {}));\n        states.forEach(s => digraph.setNode(s));\n        digraph.setInitial(initial);\n        (accept || []).forEach(s => digraph.setAccepted(s, { peripheries: 2 }));\n        (transitions || []).forEach(t => digraph.setTransition(t[0], t[2], t[1]));\n\n        return digraph\n    }\n\n    private reachable(): Set<string> {\n        const start = this.initial;\n        const queue = [start];\n        const visited = new Set([start]);\n\n        while (queue.length > 0) {\n            const current = queue.pop();\n\n            for (const transition of this.transitions()) {\n                if (current === transition.v) {\n                    if (!visited.has(transition.w)) {\n                        visited.add(transition.w);\n\n                        if (!queue.includes(transition.w)) {\n                            queue.push(transition.w);\n                        }\n                    }\n                }\n            }\n        }\n\n        return visited;\n    }\n\n    private setDiff<T>(a: Set<T>, b: Set<T>): Set<T> {\n        return new Set([...a].filter(value => !b.has(value)));\n    }\n\n    private setIntersect<T>(a: Set<T>, b: Set<T>): Set<T> {\n        return new Set([...a].filter(value => b.has(value)));\n    }\n}\n\nexport const parse = (input: string): StateMachineDescription => {\n    const initial = parse_initial(input)!;\n    const states = parse_states(input)!;\n    const accept = parse_accepting(input);\n    const alphabet = parse_alphabet(input);\n    const transitions = parse_transitions(input);\n\n    return { initial, states, accept, alphabet, transitions };\n}\n\nconst parse_states = (input: string): string[] | null => {\n    const statesMatch = PATTERNS.STATES.exec(input);\n    return statesMatch && statesMatch[1] ? statesMatch[1].split(/\\s+/).map(s => s.trim()).filter(s => s !== \"\") : null;\n}\n\nconst parse_initial = (input: string): string | null => {\n    const initialMatch = PATTERNS.INITIAL.exec(input);\n\n    return initialMatch && initialMatch[1] ? initialMatch[1] : null;\n}\n\nconst parse_accepting = (input: string): string[] => {\n    const acceptMatch = PATTERNS.ACCEPTING.exec(input);\n    return acceptMatch && acceptMatch[1] ? acceptMatch[1].split(/\\s+/).map(s => s.trim()).filter(s => s !== \"\") : [];\n}\n\nconst parse_alphabet = (input: string): string[] => {\n    const alphabetMatch = PATTERNS.ALPHABET.exec(input);\n    return alphabetMatch && alphabetMatch[1] ? alphabetMatch[1].split(/\\s*/).map(c => c.trim()).filter(c => c !== \"\") : [];\n};\n\nconst parse_transitions = (input: string): [string, string, string][] => {\n    const transMatch = PATTERNS.TRANSITIONS.exec(input);\n\n    if (!transMatch) {\n        return [];\n    }\n\n    return [...transMatch[1].matchAll(/(\\w+)\\s*,\\s*(\\w+)\\s*>\\s*(\\w+)/g)].map(t => {\n        return [t[1], t[2], t[3]];\n    });\n}\n","import React, { FunctionComponent, useState, useEffect } from 'react';\nimport { Graphviz, IGraphvizProps } from 'graphviz-react';\n\nimport dot from \"graphlib-dot\";\nimport {StateMachine, StateMachineDescription} from '../fsm';\n\ninterface Props extends Omit<IGraphvizProps, \"dot\"> { minimize?: boolean; description: string | StateMachineDescription; input?: string | null; }\n\nexport const MachineSimulator: FunctionComponent<Props> = ({ minimize, description, input, ...props }) => {\n    const [error, setError] = useState(\"\");\n    const [parsed, setParsed] = useState<string | null>(null);\n\n    useEffect(() => {\n        try {\n            const graph = StateMachine.parse(description);\n            const fsm = minimize ? graph.minimize() : graph;\n\n            if (input !== null) {\n                const finalNode = fsm.testInput(input || \"\");\n                if (finalNode) {\n                    const node = fsm.node(finalNode);\n                    fsm.setNode(finalNode, { ...node, fillcolor: \"#f54f4c\", style: \"filled\" });\n                }\n            }\n\n            const output = minimize ? dot.write(graph.minimize()) : dot.write(graph);\n            dot.read(output);\n            setParsed(output);\n            setError('');\n        } catch (e) {\n            setError(`${e.name}: ${e.message}`);\n            setParsed(null);\n        }\n\n        return () => {\n            setParsed(null);\n        }\n    }, [description, minimize, input])\n\n    return (\n        parsed ? <Graphviz dot={parsed} {...props}/> : <div>{error}</div>\n    )\n}\n\nMachineSimulator.defaultProps = {\n    minimize: false,\n    input: null\n}\n","import React, {useEffect, useState} from 'react';\nimport {Container, Row, Col, InputGroup, FormControl} from 'react-bootstrap';\n\nimport { MachineSimulator } from '../components';\nimport {StateMachine} from \"../fsm\";\n\nconst DEFAULT_MACHINE = `:states:\na\nb\n:initial:\na\n:accept:\nb\na\n:alphabet:\n0\n1\n:transitions:\na, 0 > b\na, 1 > b\nb, 0 > b\nb, 1 > a`;\n\nexport const Minimizer = () => {\n  const [description, setDescription] = useState<string>(DEFAULT_MACHINE);\n  const [minimized, setMinimized] = useState<string>(\"\");\n  const [hash, setHash] = useState(\"\");\n  const [minimizedHash, setMinimizedHash] = useState(\"\");\n\n    useEffect(() => {\n      try {\n        const base = StateMachine.parse(description);\n        const machine = base.minimize();\n        setMinimized(machine.description());\n        setHash(base.hash());\n        setMinimizedHash(machine.hash());\n      } catch {\n        setMinimized({} as any)\n      }\n    }, [description])\n\n    return (\n        <Container>\n          <h1>DFA Minimizer</h1>\n          <Row>\n            <Col>\n              <Container>\n                <Row>\n                  <h2>Input Description</h2>\n                  <InputGroup style={{ height: \"375px\" }}>\n                    <InputGroup.Prepend>\n                      <InputGroup.Text>Input</InputGroup.Text>\n                    </InputGroup.Prepend>\n                    <FormControl value={description} as={\"textarea\"} aria-label=\"input\" onChange={(e) => setDescription(e.target.value)} />\n                  </InputGroup>\n                </Row>\n                <br/>\n                <Row>\n                  <InputGroup style={{ height: \"90px\", width: \"100%\" }}>\n                    <InputGroup.Prepend>\n                      <InputGroup.Text>Hash</InputGroup.Text>\n                    </InputGroup.Prepend>\n                    <FormControl disabled as={\"textarea\"} aria-label=\"input\" value={hash} />\n                  </InputGroup>\n                </Row>\n                <br/>\n                <Row>\n                  <h2>Input Machine</h2>\n                  <MachineSimulator description={description} options={{ height: 200 }} />\n                </Row>\n              </Container>\n            </Col>\n            <Col>\n              <Container>\n                <Row>\n                  <h2>Minimized Description</h2>\n                  <InputGroup style={{ height: \"375px\" }}>\n                    <InputGroup.Prepend>\n                      <InputGroup.Text>Input</InputGroup.Text>\n                    </InputGroup.Prepend>\n                    <FormControl disabled as={\"textarea\"} value={minimized} />\n                  </InputGroup>\n                </Row>\n                <br/>\n                <Row>\n                  <InputGroup style={{ height: \"90px\"}}>\n                    <InputGroup.Prepend>\n                      <InputGroup.Text>Hash</InputGroup.Text>\n                    </InputGroup.Prepend>\n                    <FormControl disabled as={\"textarea\"} aria-label=\"input\" value={minimizedHash} />\n                  </InputGroup>\n                </Row>\n                <br/>\n                <Row>\n                  <h2>Output Machine</h2>\n                  <MachineSimulator description={description} minimize options={{ height: 200 }} />\n                </Row>\n              </Container>\n            </Col>\n          </Row>\n        </Container>\n    )\n}\n","import React, {useEffect, useState} from 'react';\nimport {Container, InputGroup, FormControl, Row, Col} from 'react-bootstrap';\n\nimport { MachineSimulator } from '../components';\nimport {StateMachine} from \"../fsm\";\n\nexport const Simulator = () => {\n    const [description, setDescription] = useState<string>(DEFAULT_MACHINE);\n    const [input, setInput] = useState(\"\");\n    const [accepted, setAccepted] = useState(false);\n    const [hash, setHash] = useState(\"\");\n\n    useEffect(() => {\n        try {\n            const machine = StateMachine.parse(description);\n            setAccepted(machine.isAccepted(input));\n            setHash(machine.hash());\n        } catch {\n            setAccepted(false);\n        }\n    }, [description, input]);\n\n    return (\n      <Container>\n          <h1>DFA Simulator</h1>\n          <Row>\n              <Col>\n                  <h2>Input Description</h2>\n                  <InputGroup style={{ height: \"375px\" }}>\n                      <InputGroup.Prepend>\n                          <InputGroup.Text>Input</InputGroup.Text>\n                      </InputGroup.Prepend>\n                      <FormControl as={\"textarea\"} aria-label=\"input\" value={description} onChange={(e) => setDescription(e.target.value)} />\n                  </InputGroup>\n                  <br/>\n                  <InputGroup style={{ height: \"90px\"}}>\n                      <InputGroup.Prepend>\n                          <InputGroup.Text>Hash</InputGroup.Text>\n                      </InputGroup.Prepend>\n                      <FormControl disabled as={\"textarea\"} aria-label=\"input\" value={hash} />\n                  </InputGroup>\n              </Col>\n              <Col>\n                  <h2>Simulate Input</h2>\n                  <InputGroup>\n                      <InputGroup.Prepend>\n                          <InputGroup.Text>Input</InputGroup.Text>\n                      </InputGroup.Prepend>\n                      <FormControl aria-label=\"input\" onChange={(e) => setInput(e.target.value)} />\n                  </InputGroup>\n                  <br/>\n                  <h4>Input is {accepted ? \"ACCEPTED\" : \"NOT ACCEPTED\"}.</h4>\n                  <MachineSimulator description={description} input={input} options={{ height: 200 }} />\n              </Col>\n          </Row>\n      </Container>\n    )\n}\n\nconst DEFAULT_MACHINE = `:states:\na\nb\nc\nd\n:initial:\na\n:accept:\nc\n:alphabet:\n0\n1\n:transitions:\na,0>b\na,1>a\nb,0>d\nb,1>c\nc,0>c\nc,1>b\nd,0>d\nd,1>c`;\n","import React from 'react';\nimport {Container} from \"react-bootstrap\";\nimport {Link} from \"react-router-dom\";\n\nexport const Home = () => {\n  return <Container>\n    <h1>FSM Tools</h1>\n    <div>\n      <div>\n        <h2>Simulator</h2>\n        <p>Simulate a deterministic finite state machine by visiting the <Link to={\"/simulator\"}>simulator</Link>.</p>\n        <h2>Minimizer</h2>\n        <p>Minimize a deterministic finite state machine by visiting the <Link to={\"/minimizer\"}>minimizer</Link>.</p>\n      </div>\n      <h2>Syntax</h2>\n      <p>There is a specific syntax for defining machine descriptions.</p>\n      <h4>Sections</h4>\n      <p>Machine descriptions can contain five sections: states, initial, accept, alphabet, and transitions.</p>\n      <div>\n        <h5>States</h5>\n        <p>The states section is defined as the following:</p>\n        <code>\n          :states:<br/>\n          (alphanumeric string)<br/>\n          (alphanumeric string)<br/>\n          ...\n        </code>\n        <br/>\n        <br/>\n        <p>As an example:</p>\n        <code>\n          :states:<br/>\n          a<br/>\n          b<br/>\n        </code>\n      </div>\n      <br/>\n      <div>\n        <h5>Initial</h5>\n        <p>The initial section is defined as an alphanumeric string which is defined in the states section.</p>\n        <p>In the case of the example above:</p>\n        <code>\n          :initial:<br/>\n          a\n        </code>\n      </div>\n      <br/>\n      <div>\n        <h5>Accept</h5>\n        <p>The accept section is defined equivalent to the states section, and it must only contain a subset of strings found within the states section.</p>\n        <p>In the case of the example above:</p>\n        <code>\n          :accept:<br/>\n          b\n        </code>\n      </div>\n      <br/>\n      <div>\n        <h5>Alphabet</h5>\n        <p>The alphabet section is also defined as states, but is a different set of strings which defines the available transition symbols.</p>\n        <p>As an example:</p>\n        <code>\n          :alphabet:<br/>\n          0<br/>\n          1\n        </code>\n      </div>\n      <br/>\n      <div>\n        <h5>Transitions</h5>\n        <p>The transitions section is defined as a list of transitions of the form:</p>\n        <code>\n          :transitions:<br/>\n          state, symbol {'>'} state\n        </code>\n        <br/>\n        <br/>\n        <p>As an example:</p>\n        <code>\n          :transitions:<br/>\n          a, 0 {'>'} b<br/>\n          a, 1  {'>'} b<br/>\n          b, 0 {'>'} b<br/>\n          b, 1 {'>'} a\n        </code>\n      </div>\n    </div>\n  </Container>\n};\n","import React from 'react';\nimport { Nav, Navbar } from 'react-bootstrap';\n\nimport { Link, NavLink, Route, Switch, HashRouter as Router } from \"react-router-dom\";\nimport {Simulator, Minimizer, Home} from './pages';\n\nfunction App() {\n  return (\n    <Router basename={\"/\"}>\n      <header>\n        <Navbar className=\"mx-auto\" style={{ maxWidth: \"1150px\" }} collapseOnSelect expand=\"lg\" variant=\"light\">\n          <Navbar.Brand as={Link} to=\"/\">FSM Tools</Navbar.Brand>\n          <Navbar.Toggle aria-controls=\"responsive-navbar-nav\"/>\n          <Navbar.Collapse id=\"responsive-navbar-nav\">\n              <Nav className=\"mr-auto\">\n                  <Nav.Link className=\"text-secondary\" as={NavLink} to=\"/simulator\">Simulator</Nav.Link>\n                  <Nav.Link className=\"text-secondary\" as={NavLink} to=\"/minimizer\">Minimizer</Nav.Link>\n              </Nav>\n          </Navbar.Collapse>\n        </Navbar>\n      </header>\n      <main>\n        <Switch>\n          <Route path={\"/\"} exact>\n            <Home/>\n          </Route>\n          <Route path=\"/simulator\">\n            <Simulator/>\n          </Route>\n          <Route path=\"/minimizer\">\n            <Minimizer/>\n          </Route>\n        </Switch>\n      </main>\n    </Router>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}